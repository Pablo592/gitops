.build_image_common:
  tags:
    - servicios-ci-cd
  stage: build_image
  image: <image-registry-domain>/servicios/kaniko-git:2.2
  variables:
    DOCKERFILES: dockerfiles.txt
  before_script:
    - |

      # Función para construir y pushear una imagen a Harbor
      function build_and_push() {
        local dockerfile="$1"
        local image="$2"
        local image_latest="$3"
        local directory="$4"

        sed -i '/^\(FROM[[:space:]]*\(harbor.psi\|registry.srv\|quay.io\|ghcr.io\|public.ecr.aws\)\|FROM[[:space:]]*\$\|FROM[[:space:]]*[a-zA-Z0-9_-]\+[[:space:]]\+as\)/!s#^FROM[[:space:]]*\(.*\)#FROM <image-registry-domain>/docker-hub/\1#' "$dockerfile"

        /kaniko/executor \
          --cleanup \
          --context ./$directory \
          --dockerfile $dockerfile \
          --destination $image \
          --destination $image_latest \
          --cache="$DOCKER_BUILD_CACHE" \
          --cache-repo="$CI_REGISTRY_HARBOR/kaniko-cache/$CI_PROJECT_PATH/$PROD_BRANCH" \
          --cache-copy-layers=true \
          --cache-ttl=24h \
          $BUILD_ARGS_CMD

        echo "Imagenes $image y $image_latest pusheadas a Harbor"



        ########################### Esto se agregó para las métricas #########################
        {
          echo "$image"
        } >> built_images.txt
        ######################################################################################
      }

      find . -type f -name 'Dockerfile' -not -path "*/\.*/*" > $DOCKERFILES

      # Verificar que se encontraron Dockerfiles
      if [ ! -s "$DOCKERFILES" ]; then
        echo "[ERROR] No se encontraron Dockerfiles en el repositorio."
        exit 1
      fi

      # Configurar credenciales de Harbor
      mkdir -p /kaniko/.docker
      echo "{\"auths\":{\"$CI_REGISTRY_HARBOR\":{\"username\":\""'robot$master'"\",\"password\":\"$CI_REGISTRY_PASSWORD_HARBOR\"}}}" > /kaniko/.docker/config.json

      BUILD_ARGS_CMD=""

      # Escribimos BUILD_ARGS a un archivo temporal
      echo "$BUILD_ARGS" > build_args.txt

      if [ ! -z "$BUILD_ARGS" ]; then
        while IFS= read -r line; do
          if [ ! -z "$line" ]; then
            BUILD_ARGS_CMD="$BUILD_ARGS_CMD $line"
          fi
        done < "build_args.txt"
      fi

      echo "BUILD ARGS CMD: $BUILD_ARGS_CMD"
      
  artifacts:
    reports:
    ########################### Esto se agregó para las métricas #########################
      dotenv: built_images.txt
    ######################################################################################

build_image_dev_demo:
  image: <image-registry-domain>/servicios/kaniko:v1.16.0-debug
  extends: .build_image_common
  script:
    - |
      ########################### Esto se agregó para las métricas #########################
      : > built_images.txt
      ######################################################################################
      
      while IFS= read -r linea; do
        DIRECTORY=$(echo "$linea" | sed 's/\/Dockerfile$//; s/^\.\///')
        if [ "$DIRECTORY" == "." ]; then
          IMAGE=$HUB/$CI_COMMIT_BRANCH:$CI_COMMIT_SHORT_SHA
          IMAGE_LATEST=$HUB/$CI_COMMIT_BRANCH:latest
        else
          IMAGE=$HUB/$DIRECTORY/$CI_COMMIT_BRANCH:$CI_COMMIT_SHORT_SHA
          IMAGE_LATEST=$HUB/$DIRECTORY/$CI_COMMIT_BRANCH:latest
        fi

        build_and_push "$linea" "$IMAGE" "$IMAGE_LATEST" "$DIRECTORY"
      done < "$DOCKERFILES"
  artifacts:
    reports:
      dotenv: tag.env
    paths:
        ########################### Esto se agregó para las métricas #########################
      - built_images.txt
        ######################################################################################
  dependencies:
    - check_project
  rules:
    - if: $CI_COMMIT_BRANCH == $DEV_BRANCH || $CI_COMMIT_BRANCH == $DEMO_BRANCH

build_image_prod:
  image: <image-registry-domain>/servicios/kaniko:v1.16.0-debug
  extends: .build_image_common
  script:
    - |
      if [ "$TAG_IS_IN_PROD" != "true" ]; then
        echo "[ERROR] Tag not found in branch 'prod'."
        exit 1
      fi

      ########################### Esto se agregó para las métricas #########################
      : > built_images.txt
      ######################################################################################

      while IFS= read -r linea; do
        DIRECTORY=$(echo "$linea" | sed 's/\/Dockerfile$//; s/^\.\///')
        if [ "$DIRECTORY" == "." ]; then
          IMAGE=$HUB:$CI_COMMIT_TAG
          IMAGE_LATEST=$HUB:latest
        else
          IMAGE=$HUB/$DIRECTORY:$CI_COMMIT_TAG
          IMAGE_LATEST=$HUB/$DIRECTORY:latest
        fi

        build_and_push "$linea" "$IMAGE" "$IMAGE_LATEST" "$DIRECTORY"
      done < "$DOCKERFILES"
  artifacts:
    reports:
      dotenv: tag.env
    paths:
      - built_images.txt
  dependencies: 
    - test_tag_in_prod
    - check_project
  rules:
    - if: $CI_COMMIT_TAG


# ============================================================
# EXTRA: job que extrae las imágenes junto con otras métricas
# ============================================================

print_image:
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://<vault-domain>"
  stage: image-metrics
  image: <image-registry-domain>/servicios/alpine-mongosh-yq:1.0.0
  script:
    - | 
        #################### MONITOREO ################################################

        # Obtener secreto de Vault
        response=$(curl --http1.1 -s --request POST \
              --data '{"jwt": "'${VAULT_ID_TOKEN}'", "role": "gitops-role"}' \
              https://<vault-domain>"/v1/auth/gitlab/login)
        VAULT_TOKEN=$(echo $response | jq -r .auth.client_token)
        if [ "$VAULT_TOKEN" == "null" ]; then
            echo "[ERROR] No se pudo obtener el token de Vault."
            exit 1
        fi
        response=$(curl --http1.1 -s \
          -H "X-Vault-Token: $VAULT_TOKEN" \
          https://<vault-domain>"/v1/servicios/data/chart-base/metrics)
        if [ "$response" == "null" ]; then
            echo "[ERROR] No se pudo obtener el secreto de Vault."
            exit 1
        fi
        
        DATABASE=$(echo $response | jq -r .data.data.database)
        PASSWORD=$(echo $response | jq -r .data.data.password)
        HOST=$(echo $response | jq -r .data.data.servidor)
        USER=$(echo $response | jq -r .data.data.usuario )
  
        MONGO_URI="mongodb://$USER:$PASSWORD@$HOST:27017/$DATABASE?authSource=admin"
        
        if [ ! -s built_images.txt ]; then
          echo "[WARN] No hay imágenes para registrar"
          exit 0
        fi
        
        IMAGES_ARRAY=$(jq -R -s -c 'split("\n") | map(select(length > 0))' < built_images.txt)

        echo "[INFO] Registrando imágenes en Mongo:"
        echo "$IMAGES_ARRAY"

        mongosh "$MONGO_URI" --quiet --eval "
          db.pipelineMetrics.insertOne({
            ProjectId: \"$CI_PROJECT_ID\",
            Project: \"$CI_PROJECT_PATH\",
            Pipeline: \"PUSH-TO-HARBOR\",
            PipelineId: \"$CI_PIPELINE_ID\",
            Images: $IMAGES_ARRAY,
            CreatedAt: new Date()
          })
        "
        #################### FIN DEL MONITOREO ################################################
  dependencies:
    - build_image_dev_demo
    - build_image_prod
  rules:
    - if: $CI_COMMIT_BRANCH == $DEV_BRANCH || $CI_COMMIT_BRANCH == $DEMO_BRANCH || $CI_COMMIT_TAG